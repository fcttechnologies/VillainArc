import Foundation
import SwiftData

/// Represents a suggested or applied change to an exercise prescription.
///
/// **Sources:**
/// - `.rules`: Generated by rule engine
/// - `.ai`: Generated by Apple FoundationModels
/// - `.user`: Manual user edit
///
/// **Lifecycle:**
/// 1. Created with `decision = .pending`
/// 2. User reviews: Sets `decision` to `.accepted`, `.rejected`, or `.deferred`
/// 3. After next workout: `outcome` determined (`.good`, `.tooAggressive`, `.insufficient`)
/// 4. `outcomeReason` explains WHY (for learning)
///
/// **Learning:**
/// - Query by `catalogID` + `changeType` to see success patterns
/// - `outcomeReason` provides AI/rule reasoning for future suggestions
/// - `targetPlan` tracks context (same exercise, different plans may progress differently)
@Model
class PrescriptionChange {
    var id: UUID = UUID()
    var source: SuggestionSource = SuggestionSource.rules
    var catalogID: String = ""
    
    // When/where triggered
    @Relationship(deleteRule: .nullify)
    var sessionFrom: WorkoutSession?
    var createdAt: Date = Date()              // When suggestion was created
    
    // Evidence (what led to this suggestion)
    @Relationship(deleteRule: .nullify)
    var sourceExercisePerformance: ExercisePerformance?
    @Relationship(deleteRule: .nullify)
    var sourceSetPerformance: SetPerformance?
    
    // Target (what prescription this affects)
    @Relationship(deleteRule: .nullify)
    var targetExercisePrescription: ExercisePrescription?
    @Relationship(deleteRule: .nullify)
    var targetSetPrescription: SetPrescription?
    @Relationship(deleteRule: .nullify)
    var targetPlan: WorkoutPlan?              // Which plan (context matters)
    
    // The Change
    var changeType: ChangeType = ChangeType.increaseWeight
    var previousValue: Double?
    var newValue: Double?
    var changeReasoning: String?              // Why suggest this change
    
    // Decision (user choice)
    var decision: Decision = Decision.pending
    
    // Outcome (how it went)
    var outcome: Outcome = Outcome.pending
    var outcomeReason: String?                // WHY this outcome (for learning)
    @Relationship(deleteRule: .nullify)
    var evaluatedInSession: WorkoutSession?   // Which session evaluated
    var evaluatedAt: Date?                    // When outcome was determined
    
    init() {}

    // Test/sample initializer to reduce setup boilerplate.
    convenience init(source: SuggestionSource = .rules, catalogID: String = "", sessionFrom: WorkoutSession? = nil, createdAt: Date = Date(), sourceExercisePerformance: ExercisePerformance? = nil, sourceSetPerformance: SetPerformance? = nil, targetExercisePrescription: ExercisePrescription? = nil, targetSetPrescription: SetPrescription? = nil, targetPlan: WorkoutPlan? = nil, changeType: ChangeType = .increaseWeight, previousValue: Double? = nil, newValue: Double? = nil, changeReasoning: String? = nil, decision: Decision = .pending, outcome: Outcome = .pending, outcomeReason: String? = nil, evaluatedInSession: WorkoutSession? = nil, evaluatedAt: Date? = nil) {
        self.init()
        self.source = source
        self.catalogID = catalogID
        self.sessionFrom = sessionFrom
        self.createdAt = createdAt
        self.sourceExercisePerformance = sourceExercisePerformance
        self.sourceSetPerformance = sourceSetPerformance
        self.targetExercisePrescription = targetExercisePrescription
        self.targetSetPrescription = targetSetPrescription
        self.targetPlan = targetPlan
        self.changeType = changeType
        self.previousValue = previousValue
        self.newValue = newValue
        self.changeReasoning = changeReasoning
        self.decision = decision
        self.outcome = outcome
        self.outcomeReason = outcomeReason
        self.evaluatedInSession = evaluatedInSession
        self.evaluatedAt = evaluatedAt
    }
}
