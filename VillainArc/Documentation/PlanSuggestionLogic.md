# Plan Suggestion System – Complete Specification

## Table of Contents

1. [Overview](#overview)
2. [Core Concepts](#core-concepts)
3. [Workflow Scenarios](#workflow-scenarios)
4. [Data Model Summary](#data-model-summary)
5. [Suggestion Generation System](#suggestion-generation-system)
6. [Outcome Evaluation System](#outcome-evaluation-system)
7. [Context Gathering Tools](#context-gathering-tools)
8. [AI Integration (V1)](#ai-integration-v1)
9. [Implementation Roadmap](#implementation-roadmap)

---

## Overview

The suggestion system learns from workout performance and provides intelligent recommendations for prescription adjustments. It combines:
- **Rule-based generation** for deterministic, transparent suggestions
- **User modification tracking** for learning what works
- **Outcome evaluation** for measuring suggestion effectiveness
- **Future AI enhancement** via Apple FoundationModels for refined suggestions

### Design Principles

1. **User Control**: Suggestions never auto-apply; user always decides
2. **Transparency**: Show reasoning for each suggestion
3. **Learning**: Track decision + outcome separately for feedback loop
4. **Reconciliation**: User edits override pending suggestions cleanly
5. **Context-Aware**: Consider history, trends, and user context

---

## Core Concepts

### Terms

| Term | Definition |
|------|------------|
| **Prescription** | Target values in a plan (weight, reps, rest, rep range, etc.) |
| **Performance** | What the user actually did during a workout |
| **Suggestion** | A proposed change to a prescription (stored as `PrescriptionChange`) |
| **Decision** | User's choice: pending → accepted / rejected / deferred / userOverride |
| **Outcome** | Result evaluation after future workouts: pending → good / tooAggressive / tooEasy / ignored / userModified |
| **Change Grouping** | Multiple atomic changes displayed as one suggestion in UI |

### PrescriptionChange Model

```swift
@Model
class PrescriptionChange {
    var id: UUID
    var source: SuggestionSource          // .rules / .ai / .user
    var catalogID: String                 // Exercise catalog ID
    
    // When/where triggered
    var sessionFrom: WorkoutSession?      // Session that generated this
    var createdAt: Date
    
    // Evidence
    var sourceExercisePerformance: ExercisePerformance?
    var sourceSetPerformance: SetPerformance?
    
    // Target
    var targetExercisePrescription: ExercisePrescription?
    var targetSetPrescription: SetPrescription?
    
    // The Change
    var changeType: ChangeType
    var previousValue: Double?
    var newValue: Double?
    var changeReasoning: String?          // Human-readable explanation
    
    // Decision (what user chose)
    var decision: Decision                // pending / accepted / rejected / deferred / userOverride
    
    // Outcome (how it performed)
    var outcome: Outcome                  // pending / good / tooAggressive / tooEasy / ignored / userModified
    var evaluatedInSession: WorkoutSession?
    var evaluatedAt: Date?
}
```

### Enums

**Decision**
```swift
enum Decision: String {
    case pending        // Not yet reviewed
    case accepted       // User accepted and applied
    case rejected       // User explicitly rejected
    case deferred       // "Not now" - show again next time
    case userOverride   // User manually edited the same target, invalidating this suggestion
}
```

**Outcome**
```swift
enum Outcome: String {
    case pending        // Not yet evaluated (need future workout data)
    case good           // Change worked well
    case tooAggressive  // User struggled (failed reps, excessive fatigue)
    case tooEasy        // User exceeded targets easily
    case ignored        // User accepted but didn't follow during workout
    case userModified   // User manually changed prescription, can't evaluate
}
```

**SuggestionSource**
```swift
enum SuggestionSource: String {
    case rules          // Generated by deterministic rules
    case ai             // Generated by Apple FoundationModels
    case user           // User manual edit (tracked for learning)
}
```

---

## Workflow Scenarios

### Scenario 1: Session without Plan

**Flow:**
1. User starts workout without selecting a plan
2. Session records performances (exercise + set data)
3. End-of-session summary shows:
   - PRs (1RM, max weight, volume)
   - "Create Plan from this session" option
4. If user creates plan:
   - New plan is created with prescriptions based on performances
   - Optionally run suggestion generation immediately (for initial baseline suggestions)

**Key Point**: No suggestions exist yet, but plan is ready for future suggestion generation after next workout.

---

### Scenario 2: First Time Using a Plan

**Flow:**
1. User starts workout from a plan
2. Prescriptions exist (targets), no suggestions yet
3. During workout: track performances
4. After workout (session done):
   - Run **suggestion generator** comparing prescription vs performance
   - Create `PrescriptionChange` records with:
     - `source = .rules`
     - `decision = .pending`
     - `outcome = .pending`
   - Suggestions are stored and will be presented at next session start

**Key Point**: First generation establishes baseline suggestions based purely on performance vs targets. These suggestions will be shown in `DeferredSuggestionsView` when user starts their next workout with this plan.

---

### Scenario 3: Starting Workout with Pending/Deferred Suggestions

**Check on Session Start:**
1. User taps "Start Workout" with a plan
2. System checks for pending or deferred suggestions for this plan
3. If found:
   - `WorkoutSessionContainer` is created with session
   - Instead of showing `WorkoutView`, show `DeferredSuggestionsView`
4. User reviews suggestions in `DeferredSuggestionsView`:
   - **Accept**: Apply changes to prescriptions, keep `outcome = .pending`
   - **Reject**: Mark `decision = .rejected`, keep `outcome = .pending` (still track quality)
   - **Skip**: Treated as reject (user not interested)
5. Once all reviewed:
   - Transition to `WorkoutView` to begin workout

**Grouping**: Multiple atomic changes displayed as one suggestion in UI (see `SuggestionGrouping.swift`)

Example in `DeferredSuggestionsView`:
```
[Bench Press - Set 1]
• Weight: 135 → 140 lbs
• Reps: 12 → 10
Reasoning: "Hit top of rep range (12 reps) for 2 consecutive sessions"
[Accept] [Reject] [Skip]
```

**Implementation:**
```swift
// In WorkoutSessionContainer or similar
func checkForPendingSuggestions(plan: WorkoutPlan, context: ModelContext) -> [PrescriptionChange] {
    let exerciseIDs = Set(plan.exercises.map { $0.id })
    let setIDs = Set(plan.exercises.flatMap { $0.sets.map { $0.id } })
    
    let descriptor = FetchDescriptor<PrescriptionChange>()
    guard let allChanges = try? context.fetch(descriptor) else { return [] }
    
    return allChanges.filter { change in
        (change.decision == .deferred || change.decision == .pending) &&
        (exerciseIDs.contains(change.targetExercisePrescription?.id ?? UUID()) ||
         setIDs.contains(change.targetSetPrescription?.id ?? UUID()))
    }
}

// In view logic
@State private var showDeferredSuggestions = false
@State private var pendingSuggestions: [PrescriptionChange] = []

var body: some View {
    if showDeferredSuggestions {
        DeferredSuggestionsView(
            suggestions: pendingSuggestions,
            onComplete: {
                showDeferredSuggestions = false
                // Continue to workout
            }
        )
    } else {
        WorkoutView(session: session)
    }
}
```

**Key Point**: Suggestions are ONLY shown at session start, NOT when viewing the plan. This forces decision-making before workout begins.

---

### Scenario 4: Reviewing Suggestions (NOT in Plan View)

**Important**: Users do NOT see suggestions when casually browsing a workout plan. Suggestions are only presented at session start (Scenario 3 above).

**Why**: This design ensures:
- User doesn't accidentally ignore suggestions
- Decision-making happens at the right time (when about to workout)
- Plan view stays focused on prescription content

---

### Scenario 5: User Edits Plan with Pending Suggestions

**Problem**: User manually changes a prescription that has pending suggestions targeting it.

**Rule: User Modification Overrides Suggestion**

When user edits a prescription (via `WorkoutPlan+Editing.swift`):

1. **Detect the edit** during `detectChanges(comparedTo:)`
2. **Create user change record**:
   - `source = .user`
   - `decision = .accepted` (auto-accepted, it's their edit)
   - `outcome = .pending` (can still learn if it was good)
3. **Mark conflicting suggestions**:
   - Any pending/deferred suggestions targeting the same property → `decision = .userOverride`, `outcome = .userModified`

**Example:**
- AI suggests: "Set 1 weight: 135 → 140" (pending)
- User edits: "Set 1 weight: 135 → 145"
- Result:
  - AI suggestion marked: `decision = .userOverride`, `outcome = .userModified`
  - User edit tracked: `source = .user`, `decision = .accepted`, `outcome = .pending`

**Current Implementation**: `WorkoutPlan+Editing.swift` already handles this via:
- `markMatchingPendingChanges()` for specific property changes
- `markPendingAsUserOverride()` for deleted items

---

### Scenario 6: Outcome Evaluation (Post-Workout)

**Trigger**: After completing a workout session with the plan

**Process:**
1. Fetch all changes with `outcome = .pending` for this plan's prescriptions
2. For each change, evaluate based on new performance data:
   - Compare new performance to prescription
   - Apply evaluation rules (see [Outcome Evaluation System](#outcome-evaluation-system))
3. Set `outcome` to: `.good`, `.tooAggressive`, `.tooEasy`, or `.ignored`
4. Record `evaluatedInSession` and `evaluatedAt`

**Key Point**: Outcomes feed back into future suggestion generation for learning.

---

## Data Model Summary

### Existing Models (No Changes Needed)

**WorkoutPlan**
- Has many `ExercisePrescription`
- Has `originalPlan` reference for editing copies
- Has `isEditing` flag

**ExercisePrescription**
- Has many `SetPrescription`
- Has many `PrescriptionChange` (inverse relationship)
- Has `repRange: RepRangePolicy`
- Has `restTimePolicy: RestTimePolicy`

**SetPrescription**
- Has many `PrescriptionChange` (inverse relationship)
- Has targets: `targetWeight`, `targetReps`, `targetRest`, `type`

**WorkoutSession**
- Has many `ExercisePerformance`
- Has `workoutPlan` reference (nullable for freeform sessions)
- Has `preMood: PreWorkoutMood` and `postEffort: PostWorkoutEffort`

**ExercisePerformance**
- Has many `SetPerformance`
- Has `prescription` reference (nullable)
- Tracks actual rep/rest policies used

**SetPerformance**
- Has `prescription` reference (nullable)
- Tracks actual: `weight`, `reps`, `restSeconds`, `type`, `complete`
- Computes: `estimated1RM`, `volume`

**PrescriptionChange** (Already Complete)
- Tracks source, target, change, decision, outcome
- All relationships in place

---

## Suggestion Generation System

### When to Generate

1. **After workout completion** (from plan)
2. **Optionally after plan creation** (from freeform session) for baseline
3. **Never during workout** (only after finalization)

### Generator Entry Point

```swift
@MainActor
class SuggestionGenerator {
    /// Generates suggestions by comparing prescription vs performance
    static func generateSuggestions(
        for session: WorkoutSession,
        context: ModelContext
    ) {
        guard let plan = session.workoutPlan else {
            print("No plan associated, skipping suggestion generation")
            return
        }
        
        for exercisePerf in session.sortedExercises {
            guard let prescription = exercisePerf.prescription else { continue }
            generateForExercise(
                performance: exercisePerf,
                prescription: prescription,
                session: session,
                context: context
            )
        }
    }
    
    private static func generateForExercise(
        performance: ExercisePerformance,
        prescription: ExercisePrescription,
        session: WorkoutSession,
        context: ModelContext
    ) {
        // Apply rules based on rep range mode, set types, performance
        // (See rule implementations below)
    }
}
```

### Set Type Eligibility & Classification

**Critical Foundation**: Different set types serve different training purposes and must be treated differently for progression.

```swift
enum SetEligibility {
    case workingSet       // Primary progression drivers
    case supportSet       // Secondary stimulus (fatigue-biased)
    case warmupSet        // Preparation only (never drive progression)
}

extension ExerciseSetType {
    var eligibility: SetEligibility {
        switch self {
        case .regular:
            return .workingSet
        case .failure, .dropSet, .superSet:
            return .supportSet
        case .warmup:
            return .warmupSet
        }
    }
    
    var shouldDriveProgression: Bool {
        eligibility == .workingSet
    }
}
```

**Progression Set Selection (Adaptive):**

Different training styles require different selection strategies:

```swift
enum TrainingStyle {
    case heaviestFirst    // Start heavy, decrease weight (e.g., 5x5 style)
    case pyramidUp        // Warmup → 1-2 top sets → backoff
    case straightSets     // Same weight all sets
    case unknown          // First time seeing this pattern
}

func selectProgressionSets(from performance: ExercisePerformance) -> [SetPerformance] {
    let completeSets = performance.sortedSets.filter { $0.complete }
    guard !completeSets.isEmpty else { return [] }
    
    // Strategy 1: If user marks sets properly, trust set types
    let regularSets = completeSets.filter { $0.type == .regular }
    if regularSets.count >= 2 {
        // User marks sets properly - trust their labeling
        // Take top 2 regular sets by weight (handles both styles)
        return Array(regularSets.sorted { $0.weight > $1.weight }.prefix(2))
    }
    
    // Strategy 2: User doesn't mark set types - infer from weight pattern
    if regularSets.isEmpty {
        // All sets are marked as .regular or user doesn't change types
        // Detect training style from weight pattern
        let style = detectTrainingStyle(completeSets)
        
        switch style {
        case .heaviestFirst:
            // Take first 1-2 sets (heaviest)
            return Array(completeSets.prefix(2))
            
        case .pyramidUp:
            // Find peak weight set(s) - likely in middle
            let maxWeight = completeSets.map { $0.weight }.max() ?? 0
            let topSets = completeSets.filter { $0.weight >= maxWeight * 0.95 } // Within 5% of max
            return Array(topSets.sorted { $0.index < $1.index }.prefix(2))
            
        case .straightSets:
            // Similar weight all sets - take first 2
            return Array(completeSets.prefix(2))
            
        case .unknown:
            // First time - take heaviest 2 sets by weight
            return Array(completeSets.sorted { $0.weight > $1.weight }.prefix(2))
        }
    }
    
    // Strategy 3: Some regular sets exist but < 2
    // Combine regular + heaviest non-warmup
    var selected = regularSets
    if selected.count < 2 {
        let nonWarmup = completeSets.filter { $0.type != .warmup }
        let additional = nonWarmup
            .filter { !selected.contains($0) }
            .sorted { $0.weight > $1.weight }
        selected.append(contentsOf: Array(additional.prefix(2 - selected.count)))
    }
    
    return selected
}

func detectTrainingStyle(_ sets: [SetPerformance]) -> TrainingStyle {
    guard sets.count >= 3 else { return .unknown }
    
    let weights = sets.map { $0.weight }
    
    // Check if weights are generally decreasing (heaviest first)
    let descendingCount = zip(weights, weights.dropFirst()).filter { $0 > $1 }.count
    if descendingCount >= sets.count - 2 {
        return .heaviestFirst
    }
    
    // Check if weights ramp up then down (pyramid)
    let maxWeight = weights.max() ?? 0
    let maxIndex = weights.firstIndex(of: maxWeight) ?? 0
    if maxIndex > 0 && maxIndex < weights.count - 1 {
        // Peak is in the middle
        return .pyramidUp
    }
    
    // Check if weights are similar (straight sets)
    let avgWeight = weights.reduce(0, +) / Double(weights.count)
    let allSimilar = weights.allSatisfy { abs($0 - avgWeight) < avgWeight * 0.1 } // Within 10%
    if allSimilar {
        return .straightSets
    }
    
    return .unknown
}
```

**Why This Matters:**
- **Warmup sets** are too light to indicate true capacity
- **Drop/super sets** are fatigue-biased and shouldn't trigger weight increases
- **Failure sets** can bias overload too aggressively
- **Regular sets** (especially first 1-2) reflect true working capacity

---

### Core Metrics (Computed Once Per Analysis)

Before applying any rules, compute these metrics for stable decision-making:

**Per-Set Metrics:**
```swift
struct SetMetrics {
    let setPerformance: SetPerformance
    let setPrescription: SetPrescription?
    let setType: ExerciseSetType
    let eligibility: SetEligibility
    
    // Targets
    let targetReps: Int
    let targetWeight: Double
    let targetRest: Int
    
    // Actuals
    let actualReps: Int
    let actualWeight: Double
    let actualRest: Int  // Computed from completedAt timestamps
    let effectiveRest: Int  // From effectiveRestSeconds (accounts for drop/super sets)
    
    // Deltas
    let repDelta: Int  // actualReps - targetReps
    let weightDelta: Double  // actualWeight - targetWeight
    
    // Boolean checks
    let hitTargetReps: Bool  // actualReps >= targetReps
    let overshotTopOfRange: Bool  // actualReps >= upperRange (if mode .range)
    let undershotBottomOfRange: Bool  // actualReps < lowerRange (if mode .range)
    let attemptedPrescribedWeight: Bool  // abs(weightDelta) < 2.5
}
```

**Per-Exercise Metrics (Across 2-3 Sessions):**
```swift
struct ExerciseMetrics {
    let exercisePerformance: ExercisePerformance
    let prescription: ExercisePrescription
    let history: [ExercisePerformance]  // Last 2-3 sessions
    
    // Set selection
    let progressionSets: [SetMetrics]  // First 1-2 regular sets from current session
    let allWorkingSets: [SetMetrics]   // All regular sets from current session
    let supportSets: [SetMetrics]      // All failure/drop/super sets
    let warmupSets: [SetMetrics]       // All warmup sets
    
    // Performance trends
    let consistencyRate: Double  // % of working sets hitting target reps
    let progressionTrend: ProgressionTrend  // .improving / .plateau / .regressing
    let sessionCount: Int  // How many sessions analyzed (need 2-3 minimum)
    let averageRepsAtWeight: Double  // For detecting stability
    let estimated1RMTrend: [Double]  // Last 3 sessions' best e1RM
    let bestEstimated1RM: Double?
    let bestWeight: Double?
    let totalVolume: Double
    
    // Historical comparison
    let historicalBestE1RM: Double?
    let historicalBestWeight: Double?
    let historicalBestVolume: Double?
    let hasProgressedRecently: Bool  // Weight increased in last 3-5 sessions
}
```

**Rest Time Calculation (Use Existing `effectiveRestSeconds`):**
```swift
func calculateActualRest(
    currentSet: SetPerformance,
    previousSet: SetPerformance?,
    exercise: ExercisePerformance
) -> Int {
    // Use the existing effectiveRestSeconds logic
    // This already handles drop/super set chains (returns 0)
    let effective = exercise.effectiveRestSeconds(after: previousSet ?? currentSet)
    
    // Also calculate actual time from timestamps for comparison
    guard let prev = previousSet,
          let prevCompleted = prev.completedAt,
          let currentCompleted = currentSet.completedAt else {
        return effective
    }
    
    let actualInterval = Int(currentCompleted.timeIntervalSince(prevCompleted))
    
    // Return actual interval, but note effective for rule decisions
    return actualInterval
}
```

**Critical Rest Rule:**
Only suggest rest increases when `effectiveRest > 0`. Never suggest rest for drop/super set chains where rest is intentionally 0.
```

**Important Note on Incomplete Sets:**
- Currently, no incomplete sets are saved
- If this changes later, add logic to detect skipped sets
- For now, all saved sets are complete, simplifying analysis

---

### Rule Categories

Rules are organized into priority tiers to avoid conflicts:

1. **Safety Rules** (highest priority): Prevent injury/overload
2. **Progressive Overload Rules**: Drive adaptation
3. **Prescription Cleanup Rules**: Match actual behavior
4. **Volume Management Rules**: Optimize set count
5. **Rest Time Rules**: Optimize recovery between sets
6. **Policy Adjustment Rules**: Fine-tune rep ranges/modes

---

### Rule Priority & Conflict Resolution

When multiple rules could apply to the same set/exercise, use this priority:

```swift
enum RulePriority: Int {
    case safety = 1           // Prevent injury
    case progressiveOverload = 2  // Drive adaptation
    case cleanup = 3          // Match behavior
    case volume = 4           // Adjust set count
    case rest = 5             // Rest time tweaks
    case policy = 6           // Rep range adjustments
}
```

**Conflict Resolution:**
- If two rules target the same property (e.g., both want to change weight), pick higher priority
- If same priority, pick the one with stronger evidence (more sessions, larger delta)
- Never emit both `increaseWeight` and `decreaseWeight` for same set

---

### 1. Safety Rules (Priority 1)

#### Rule 1.1: Below Range Consistently → Reduce Weight

**Applies To:** Regular working sets only

**Trigger:**
- Rep range mode is `.range`
- User falls below `lowerRange` on **regular working sets** (progression sets)
- **Stability Check**: Occurred in 2 of last 3 sessions for same set indices
- User attempted prescribed weight (abs(weightDelta) < 2.5 lbs)

**Evidence:**
```swift
func shouldReduceWeight(
    metrics: ExerciseMetrics,
    history: [ExercisePerformance],
    prescription: ExercisePrescription
) -> Bool {
    let last3 = Array(history.prefix(3))
    guard last3.count >= 2 else { return false }
    
    var belowRangeCount = 0
    for exercisePerf in last3 {
        // Only check first 1-2 regular sets (progression sets)
        let regularSets = exercisePerf.sortedSets.filter { $0.type == .regular && $0.complete }
        let topSets = Array(regularSets.prefix(2))
        
        for setPerf in topSets {
            let prescribed = prescription.sortedSets[safe: setPerf.index]?.targetWeight ?? 0
            let attemptedPrescribed = abs(setPerf.weight - prescribed) < 2.5
            
            if setPerf.reps < prescription.repRange.lowerRange && attemptedPrescribed {
                belowRangeCount += 1
            }
        }
    }
    
    return belowRangeCount >= 2
}
```

**Suggestions:**
- `decreaseWeight` by 5-10% on affected regular sets only
- Optional: `increaseRest` if `effectiveRest > 0` and rest was consistently short

**Reasoning:**
```
"You've fallen below the minimum rep range ({lowerRange}) in 2 of the last 3 sessions. Reducing weight by {amount} will let you train within the intended stimulus range."
```

**Important:** Don't reduce weight on warmup/drop/super/failure sets based on this rule.

---

### 2. Progressive Overload Rules (Priority 2)

#### Rule 2.1: Double Progression (Range Mode) → Add Weight & Reset Reps

**Applies To:** Regular working sets only (progression sets)

**Trigger:**
- Rep range mode is `.range`
- User hits `upperRange` or above on **progression sets** (first 1-2 regular sets)
- **Stability Check**: Occurred in 2 consecutive sessions for same set indices
- Only applies to `.regular` sets (warmup/drop/super/failure excluded)

**Evidence:**
```swift
func shouldProgressWeight(
    metrics: ExerciseMetrics,
    history: [ExercisePerformance],
    prescription: ExercisePrescription
) -> Bool {
    let last2 = Array(history.prefix(2))
    guard last2.count == 2 else { return false }
    
    // Check if progression sets (first 1-2 regular) hit top in both sessions
    for exercisePerf in last2 {
        let regularSets = exercisePerf.sortedSets.filter { $0.type == .regular && $0.complete }
        let progressionSets = Array(regularSets.prefix(2))
        
        guard !progressionSets.isEmpty else { return false }
        
        let hitTop = progressionSets.allSatisfy { $0.reps >= prescription.repRange.upperRange }
        if !hitTop { return false }
    }
    
    return true
}
```

**Weight Increment (Fallback Logic):**
```swift
func determineWeightIncrement(
    currentWeight: Double,
    primaryMuscle: Muscle? = nil
) -> Double {
    // Option A: If muscle is known (best)
    if let muscle = primaryMuscle {
        switch muscle {
        // Upper body major muscles
        case .chest, .shoulders, .back:
            return 5.0  // +5 lbs
        case .biceps, .triceps:
            return 5.0  // +5 lbs
        
        // Upper body minor muscles (delts, lats, traps, etc.)
        case .frontDelt, .sideDelt, .rearDelt, .lats, .lowerBack,
             .upperTraps, .lowerTraps, .midTraps, .rhomboids:
            return 5.0  // +5 lbs
        case .longHeadBiceps, .shortHeadBiceps, .brachialis,
             .longHeadTriceps, .lateralHeadTriceps, .medialHeadTriceps:
            return 5.0  // +5 lbs
        
        // Lower body major muscles
        case .quads, .hamstrings, .glutes:
            return 10.0  // +10 lbs
        case .calves:
            return 10.0  // +10 lbs
        
        // Lower body minor
        case .adductors, .abductors:
            return 5.0  // +5 lbs
        
        // Core
        case .abs, .obliques, .upperAbs, .lowerAbs:
            return 5.0  // +5 lbs
        
        // Misc
        case .forearms, .wrists, .rotatorCuff:
            return 2.5  // +2.5 lbs (smaller muscle groups)
        
        // Chest variants (treat as chest)
        case .upperChest, .lowerChest, .midChest:
            return 5.0  // +5 lbs
        }
    }
    
    // Option B: Weight-based fallback (if muscle unknown)
    if currentWeight < 50 {
        return 2.5  // Small weights: +2.5 lbs
    } else if currentWeight < 150 {
        return 5.0  // Medium weights: +5 lbs
    } else {
        return 10.0  // Heavy weights: +10 lbs
    }
}
```

**Suggestions (Grouped):**
For each regular working set that triggered the rule:
1. `increaseWeight` by increment
2. `decreaseReps` to `lowerRange` (reset to bottom of range)

**Reasoning:**
```
"You've hit the top of your rep range ({upperRange} reps) for 2 consecutive sessions. Increase weight by {increment} and reset reps to {lowerRange} to continue progressive overload."
```

**Important:** 
- Only apply to regular working sets
- Don't suggest weight increases for warmup/failure/drop/super sets based on this rule

---

#### Rule 2.2: Double Progression (Target Mode) → Add Weight

**Trigger:**
- Rep range mode is `.target`
- User exceeds `targetReps` by 2+ reps
- **Stability Check**: Occurred in 2 consecutive sessions

**Evidence:**
```swift
func shouldProgressWeightTarget(history: [ExercisePerformance], prescription: ExercisePrescription) -> Bool {
    let last2 = Array(history.prefix(2))
    guard last2.count == 2 else { return false }
    
    for exercisePerf in last2 {
        let topSets = exercisePerf.sortedSets.filter { $0.type == .regular }.prefix(2)
        let exceeded = topSets.allSatisfy { $0.reps >= prescription.repRange.targetReps + 2 }
        if !exceeded { return false }
    }
    
    return true
}
```

**Suggestions:**
- `increaseWeight` by increment
- Optional: keep `targetReps` same or slightly increase

**Reasoning:**
```
"You've exceeded your rep target by 2+ reps for 2 consecutive sessions. Increase weight by {increment} to maintain challenge."
```

---

#### Rule 2.3: Large Overshoot → Bigger Weight Jump

**Trigger:**
- User overshoots `upperRange` by 4+ reps (or `targetReps` by 5+)
- **Stability Check**: Occurred in last 2 sessions
- Suggests load was significantly too light

**Suggestions:**
- `increaseWeight` by 1.5x normal increment (e.g., +7.5 lbs instead of +5)
- Reset reps appropriately

**Reasoning:**
```
"You've significantly exceeded the rep target ({actual} vs {target}), suggesting the load is too light. Increase weight by {increment} to match your current strength."
```

---

### 3. Prescription Cleanup Rules (Priority 3)

#### Rule 3.1: User Always Uses Different Weight → Match Behavior

**Trigger:**
- User consistently uses a different weight than prescribed
- **Stability Check**: Weight delta > 5 lbs in same direction for 3 sessions
- Suggests user found their "real" working weight

**Evidence:**
```swift
func shouldAdjustPrescribedWeight(history: [ExercisePerformance], prescription: ExercisePrescription, setIndex: Int) -> Double? {
    let last3 = Array(history.prefix(3))
    guard last3.count == 3 else { return nil }
    
    var actualWeights: [Double] = []
    for exercisePerf in last3 {
        if let setPerf = exercisePerf.sortedSets[safe: setIndex] {
            actualWeights.append(setPerf.weight)
        }
    }
    
    guard actualWeights.count == 3 else { return nil }
    
    let avgActual = actualWeights.reduce(0, +) / Double(actualWeights.count)
    let prescribed = prescription.sortedSets[safe: setIndex]?.targetWeight ?? 0
    
    if abs(avgActual - prescribed) > 5.0 {
        return avgActual
    }
    
    return nil
}
```

**Suggestions:**
- `increaseWeight` or `decreaseWeight` to match average actual weight

**Reasoning:**
```
"You've consistently used {actual}lbs instead of prescribed {target}lbs for 3 sessions. Updating prescription to match your actual working weight."
```

---

#### Rule 3.2: Set Type Mismatch → Update Prescription

**Trigger:**
- User consistently performs set as different type (e.g., `.failure` vs `.regular`)
- **Stability Check**: Same type used for 2 consecutive sessions

**Suggestions:**
- `changeSetType` to match actual behavior

**Reasoning:**
```
"You've performed this as a {actualType} set for 2 consecutive sessions. Updating prescription to match your training style."
```

---

### 4. Volume Management Rules (Priority 4)

**Important**: These are conservative and require strong evidence.

#### Rule 4.1: Add Set (Very Rare)

**Trigger:**
- All working sets hit top of range easily for 3+ sessions
- Weight has progressed at least once in last 5 sessions (not just underloaded)
- Current set count < 5 (safety cap)
- **Stability Check**: 3 consecutive sessions

**Evidence:**
```swift
func shouldAddSet(history: [ExercisePerformance], prescription: ExercisePrescription) -> Bool {
    let last3 = Array(history.prefix(3))
    guard last3.count == 3 else { return false }
    
    // Check all 3 sessions hit top of range
    for exercisePerf in last3 {
        let workingSets = exercisePerf.sortedSets.filter { $0.type == .regular }
        let allHitTop = workingSets.allSatisfy { $0.reps >= prescription.repRange.upperRange }
        if !allHitTop { return false }
    }
    
    // Check weight progressed recently
    let last5 = Array(history.prefix(5))
    var hasProgressed = false
    for i in 1..<last5.count {
        if last5[i-1].sortedSets.first?.weight ?? 0 > last5[i].sortedSets.first?.weight ?? 0 {
            hasProgressed = true
            break
        }
    }
    
    return hasProgressed && prescription.sets.count < 5
}
```

**Suggestions:**
- `addSet` with weight matching last set (or slightly lower as backoff)

**Reasoning:**
```
"You've consistently completed all sets at the top of the rep range for 3+ sessions and have progressed in weight. Adding a set can increase training volume for further adaptation."
```

---

### 5. Rest Time Rules (Priority 5)

**Critical**: Only suggest rest changes when `effectiveRestSeconds > 0`. Never suggest rest for drop/super set chains where rest is intentionally 0.

**Note**: Rest time is calculated from `completedAt` timestamps, which includes user's actual rest plus any mid-set pauses.

#### Rule 5.1: Consistently Rest Longer → Increase Prescribed Rest

**Applies To:** Sets where `effectiveRest > 0` (not drop/super set chains)

**Trigger:**
- Actual rest (from timestamps) exceeds prescribed by 30+ seconds
- `effectiveRestSeconds > 0` (not a drop/super set chain)
- **Stability Check**: Occurred in 2 of last 3 sessions
- Performance is still good (hitting reps)

**Evidence:**
```swift
func shouldIncreaseRest(
    history: [ExercisePerformance],
    prescription: ExercisePrescription,
    setIndex: Int
) -> Int? {
    let last3 = Array(history.prefix(3))
    guard last3.count >= 2 else { return nil }
    
    var longRestCount = 0
    var totalActualRest = 0
    var count = 0
    
    for exercisePerf in last3 {
        let sets = exercisePerf.sortedSets
        guard setIndex > 0 && setIndex < sets.count else { continue }
        
        let prevSet = sets[setIndex - 1]
        let currentSet = sets[setIndex]
        
        // Check effectiveRest first - skip if 0 (drop/super set)
        let effectiveRest = exercisePerf.effectiveRestSeconds(after: prevSet)
        guard effectiveRest > 0 else { continue }
        
        if let prevCompleted = prevSet.completedAt,
           let currentCompleted = currentSet.completedAt {
            let actualRest = Int(currentCompleted.timeIntervalSince(prevCompleted))
            let prescribed = prescription.sortedSets[safe: setIndex]?.targetRest ?? 0
            
            if actualRest > prescribed + 30 {
                longRestCount += 1
                totalActualRest += actualRest
                count += 1
            }
        }
    }
    
    if longRestCount >= 2 && count > 0 {
        return totalActualRest / count
    }
    
    return nil
}
```

**Suggestions:**
- `increaseRest` or `increaseRestTimeSeconds` (depending on mode)
- Round to nearest 15s

**Reasoning:**
```
"You've consistently rested {actual}s instead of prescribed {target}s for 2+ sessions. Updating rest time to match your actual recovery needs."
```

---

#### Rule 5.2: Shorter Rest + Declining Performance → Increase Rest

**Applies To:** Sets where `effectiveRest > 0`

**Trigger:**
- Actual rest is shorter than prescribed by 15+ seconds
- `effectiveRestSeconds > 0` (not a drop/super set chain)
- Reps decline across sets or fall below range
- **Stability Check**: Pattern seen in last 2 sessions

**Suggestions:**
- `increaseRest` by 15-30s

**Reasoning:**
```
"Your rest periods are shorter than prescribed and performance drops across sets. Increasing rest should help maintain rep targets."
```

---

### 6. Set Type-Specific Rules (Priority varies)

These rules handle non-regular set types and their interactions with the program.

#### Rule 6.1: Set Type Suggestions Based on Weight Pattern

**Priority:** 3 (Cleanup)

**Purpose:** Help users who don't manually change set types by suggesting proper classification based on weight/effort patterns.

##### Rule 6.1a: Warmup Acting Like Working Set → Convert

**Trigger:**
- Set type is `.warmup`
- Weight or reps are close to top sets (within 10%)
- **Stability Check**: Pattern in 2 consecutive sessions

**Evidence:**
```swift
func shouldConvertWarmupToRegular(
    warmupSet: SetPerformance,
    topSets: [SetPerformance]  // Heaviest sets
) -> Bool {
    guard let heaviest = topSets.first else { return false }
    
    let weightRatio = warmupSet.weight / heaviest.weight
    let repRatio = Double(warmupSet.reps) / Double(heaviest.reps)
    
    // If warmup is within 10% of top working weight or doing similar reps
    return weightRatio > 0.9 || repRatio > 0.9
}
```

**Suggestions:**
- `changeSetType` warmup → regular
- OR `decreaseWeight` on warmup set to preserve it as warmup (50-70% of top weight)

**Reasoning:**
```
"This warmup is close to your heaviest sets ({warmupWeight} vs {topWeight}). Consider marking it as a working set or reducing weight to preserve it as a true warmup."
```

---

##### Rule 6.1b: Regular Set Acting Like Warmup → Suggest Warmup Type

**Trigger:**
- Set type is `.regular`
- Weight is significantly lighter than other regular sets (< 70% of heaviest)
- Set is early in sequence (index 0-1)
- **Stability Check**: Pattern in 2 consecutive sessions

**Evidence:**
```swift
func shouldConvertRegularToWarmup(
    set: SetPerformance,
    allSets: [SetPerformance]
) -> Bool {
    let regularSets = allSets.filter { $0.type == .regular }
    guard regularSets.count >= 3 else { return false }  // Need enough context
    
    let maxWeight = regularSets.map { $0.weight }.max() ?? 0
    guard maxWeight > 0 else { return false }
    
    let weightRatio = set.weight / maxWeight
    
    // First 1-2 sets that are < 70% of max might be warmups
    return set.index <= 1 && weightRatio < 0.7
}
```

**Suggestions:**
- `changeSetType` regular → warmup

**Reasoning:**
```
"This set uses {setWeight} which is {percent}% of your heaviest sets. Consider marking it as a warmup since it's significantly lighter."
```

---

##### Rule 6.1c: Suggest Regular for Heaviest Sets (When All Sets Are Same Type)

**Trigger:**
- All sets are marked as same type (e.g., all `.regular` or user never changes types)
- Clear weight progression exists (ramp up to peak then down)
- Peak weight set(s) are not marked differently
- **Stability Check**: Pattern in 2 consecutive sessions

**Evidence:**
```swift
func shouldMarkTopSetsAsRegular(
    allSets: [SetPerformance]
) -> [(SetPerformance, ExerciseSetType)] {
    guard allSets.count >= 4 else { return [] }
    
    let weights = allSets.map { $0.weight }
    let maxWeight = weights.max() ?? 0
    guard maxWeight > 0 else { return [] }
    
    var suggestions: [(SetPerformance, ExerciseSetType)] = []
    
    for (index, set) in allSets.enumerated() {
        let weightRatio = set.weight / maxWeight
        
        // Light warmup territory (< 70%)
        if weightRatio < 0.7 && index <= 2 {
            if set.type != .warmup {
                suggestions.append((set, .warmup))
            }
        }
        // Peak weight territory (>= 95%)
        else if weightRatio >= 0.95 {
            if set.type != .regular {
                suggestions.append((set, .regular))
            }
        }
        // Backoff territory (70-95%, after peak)
        else if weightRatio >= 0.7 && weightRatio < 0.95 && index > 2 {
            // Could suggest regular or backoff (if you add that type later)
            if set.type != .regular {
                suggestions.append((set, .regular))
            }
        }
    }
    
    return suggestions
}
```

**Suggestions:**
Multiple suggestions in one batch:
- Early light sets → warmup
- Peak weight sets → regular
- Later moderate sets → regular

**Reasoning:**
```
"Your weight pattern suggests a warmup → working sets → backoff structure. Marking sets by type helps track progression more accurately:
• Sets 1-2 ({lightWeight}): Warmup
• Sets 3-4 ({heavyWeight}): Working sets
• Sets 5-6 ({backoffWeight}): Additional volume"
```

**Important:** Only suggest this if user has completed 2-3 sessions with same pattern AND hasn't manually changed any set types. Don't spam users who intentionally keep everything as `.regular`.

---

#### Rule 6.2: Drop Set Without Base Set → Add Structure

**Priority:** 3 (Cleanup)

**Trigger:**
- `.dropSet` appears without a preceding `.regular` set
- OR exercise contains only drop sets

**Suggestions:**
- `changeSetType` for first drop set → regular (simplest fix)

**Reasoning:**
```
"Drop sets work best after a heavy working set. Converting first drop set to regular provides proper structure."
```

---

#### Rule 6.3: Super Sets Require Individual Rest Mode

**Priority:** 5 (Rest Time)

**Trigger:**
- Exercise contains `.superSet`
- `restTimePolicy.activeMode == .allSame`

**Suggestions:**
- `changeRestTimeMode` → `.individual`

**Reasoning:**
```
"Supersets naturally use different rest timing than regular sets. Switching to individual rest prevents regular sets from being forced to 0 rest."
```

---

#### Rule 6.4: Super Set Followed by Regular Set Performance Drop

**Priority:** 5 (Rest Time)

**Trigger:**
- `.superSet` is followed by `.regular` set
- Regular set underperforms (below lower range) compared to earlier regular sets
- **Stability Check**: Pattern in 2 sessions

**Suggestions:**
- `increaseRest` on the regular set after superset (not on superset itself)

**Reasoning:**
```
"After supersets, you need longer recovery before returning to heavy regular sets. Increase rest on regular sets that follow supersets."
```

---

#### Rule 6.5: Too Many Failure Sets → Convert to Regular

**Priority:** 3 (Cleanup)

**Trigger:**
- Count of `.failure` sets > 1 (or > 20% of total sets)
- **Stability Check**: Consistent across 2 sessions
- Next regular set shows large performance drop (>40% rep decrease)

**Suggestions:**
- `changeSetType` extra failure sets → regular

**Reasoning:**
```
"Going to failure on multiple sets is causing large performance drops on subsequent sets. Convert some to regular sets to maintain quality."
```

---

### 7. Exercise-Level Advanced Rules (Priority 2-3)

These use historical metrics across multiple sessions.

#### Rule 7.1: Stagnation Detector → Volume or Rest Increase

**Priority:** 3 (Cleanup/Optimization)

**Trigger:**
- `bestEstimated1RM` hasn't increased by ≥2% over last 3-5 sessions
- User is not missing reps (not failing, just stuck)
- **Stability Check**: 3+ sessions of plateau

**Evidence:**
```swift
func detectStagnation(metrics: ExerciseMetrics) -> Bool {
    guard metrics.sessionCount >= 3 else { return false }
    
    let e1RMs = metrics.estimated1RMTrend
    guard e1RMs.count >= 3 else { return false }
    
    let oldest = e1RMs.last ?? 0
    let newest = e1RMs.first ?? 0
    
    let improvement = (newest - oldest) / oldest
    
    // Less than 2% improvement and not regressing
    return improvement < 0.02 && improvement >= -0.02
}
```

**Suggestions (Pick one):**
- `addSet` if all sets consistently hit top of range (conservative trigger)
- OR `increaseRestTimeSeconds` by 15-30s
- OR `increaseRepRangeUpper` to allow longer progression before weight jumps

**Reasoning:**
```
"Progress has plateaued over the last {count} sessions. A small {volume/rest} increase can help drive adaptation."
```

---

#### Rule 7.2: Volume Spike + Performance Drop → Reduce Volume

**Priority:** 1 (Safety - fatigue management)

**Trigger:**
- `totalVolume` is >25% higher than recent 3-session average
- Next session performance drops significantly (reps below range, or e1RM drops >5%)
- **Stability Check**: Volume spike + drop pattern confirmed

**Suggestions:**
- `removeSet` (last set)
- OR `decreaseWeight` on last 1-2 sets

**Reasoning:**
```
"Recent volume increased sharply ({oldVolume} → {newVolume}) and performance dropped. Reduce last-set load/volume to aid recovery."
```

---

### 6. Policy Adjustment Rules (Priority 6)

#### Rule 6.1: Narrow Rep Range for Consistency

**Trigger:**
- Rep variance is high (standard deviation > 2 reps) across 3 sessions
- Current range is wide (e.g., 8-15)

**Suggestions:**
- `decreaseRepRangeUpper` to narrow window (e.g., 8-15 → 8-12)

**Reasoning:**
```
"Your reps vary significantly session-to-session. A narrower rep range can improve consistency and make progression clearer."
```

---

### Cooldown & Deduplication System

**Before generating any suggestion**, check:

1. **Recent Suggestions** (last 14 days or 2 sessions):
```swift
func hasSimilarRecentSuggestion(
    changeType: ChangeType,
    targetSet: SetPrescription?,
    targetExercise: ExercisePrescription?,
    context: ModelContext
) -> Bool {
    let descriptor = FetchDescriptor<PrescriptionChange>(
        sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
    )
    
    guard let allChanges = try? context.fetch(descriptor) else { return false }
    
    let twoWeeksAgo = Date().addingTimeInterval(-14 * 24 * 60 * 60)
    let recentChanges = allChanges.filter { $0.createdAt > twoWeeksAgo }
    
    return recentChanges.contains { change in
        change.changeType == changeType &&
        change.targetSetPrescription?.id == targetSet?.id &&
        change.targetExercisePrescription?.id == targetExercise?.id &&
        (change.decision == .pending || change.decision == .deferred || change.decision == .accepted)
    }
}
```

2. **Rejected Suggestions** (last 30 days):
```swift
func wasRecentlyRejected(
    changeType: ChangeType,
    targetSet: SetPrescription?,
    context: ModelContext
) -> Bool {
    // Similar to above but filter for decision == .rejected
    // Don't re-suggest if user explicitly rejected within last month
}
```

3. **Conflicting Suggestions**:
```swift
func resolveConflicts(_ suggestions: [PrescriptionChange]) -> [PrescriptionChange] {
    // Group by target (set or exercise)
    // If multiple suggestions target same property, keep highest priority
    // If same priority, keep stronger evidence (larger delta or more sessions)
}
```

---

### Minimum Session Requirement & History Strategy

**Core Philosophy**: Quality over speed. Better to wait for stable evidence than spam users with premature suggestions.

#### Option A: Conservative (Recommended - Start Here)
```swift
func canGenerateSuggestions(history: [ExercisePerformance]) -> Bool {
    return history.count >= 3  // Require 3 sessions for stability
}
```

**Rationale:**
- 3 sessions = 2 data points to compare (session N vs N-1, session N-1 vs N-2)
- Reduces false positives from one-off variations
- Better pattern detection (2/3 sessions showing same behavior)
- Users are more likely to trust suggestions that feel "earned"

**Rule Application:**
- **Progressive overload**: 2 of last 3 sessions hit top of range
- **Safety (below range)**: 2 of last 3 sessions miss bottom
- **Cleanup (weight drift)**: All 3 sessions show same pattern
- **Volume/Policy**: All 3 sessions show need for change

#### Option B: Balanced (After Initial Testing)
```swift
func canGenerateSuggestions(history: [ExercisePerformance]) -> Bool {
    return history.count >= 2  // Require 2 sessions minimum
}
```

**Rationale:**
- 2 sessions = faster feedback loop
- Good for simple rules (hit top → increase weight)
- Risk: More sensitive to session-to-session variation

**Rule Application:**
- **Progressive overload**: Both sessions hit top
- **Safety**: Both sessions miss bottom
- **Cleanup/Volume/Policy**: Still require 3 sessions for stability

#### Recommendation: Start with Option A (3 sessions)

**Why:**
1. You're building trust with users - premature suggestions hurt that
2. Workout performance varies naturally (sleep, stress, etc.)
3. 3 sessions = 1-2 weeks typical → reasonable wait
4. If suggestions feel wrong, users will ignore the system entirely

**Later:** After gathering data on suggestion acceptance rates, you can:
- Lower to 2 sessions if acceptance is high
- Keep at 3 if users appreciate the stability
- Make it configurable per rule (progressive overload = 2, volume = 3)

---

### History Lookup Strategy: Exercise-Based (catalogID)

**Critical Design Decision**: Suggestions are based on **exercise history** (by `catalogID`), NOT plan history.

#### Why This Matters for New Plans

When user creates a plan from a session:

```swift
// Plan created from session
let newPlan = WorkoutPlan(from: session)

// Each ExercisePrescription has catalogID
for exercise in newPlan.exercises {
    print(exercise.catalogID)  // e.g., "bench_press_barbell"
}
```

**Next workout with this new plan:**
```swift
// 1. Session starts with new plan
let session = WorkoutSession(from: newPlan)

// 2. After workout, generate suggestions
for exercisePerf in session.exercises {
    let catalogID = exercisePerf.catalogID  // "bench_press_barbell"
    
    // 3. Fetch ALL historical performances for this exercise
    let history = ExercisePerformance.matching(catalogID: catalogID)
    // This returns performances from:
    // - Previous sessions with this plan
    // - Sessions with OTHER plans using same exercise
    // - Freeform sessions that used this exercise
    
    // 4. Check if we have enough history
    if history.count >= 3 {
        // Generate suggestions based on entire exercise history
        // regardless of which plan(s) it came from
    }
}
```

#### Benefits of Exercise-Based History

1. **New plans leverage existing data**: If user benched 3 times in freeform sessions, then creates a plan, the first workout with that plan can generate suggestions immediately.

2. **Cross-plan learning**: If user has multiple plans (Upper/Lower split, PPL, etc.) all using bench press, all bench press history contributes to suggestions.

3. **No wasted data**: Every workout contributes to future suggestions for that exercise.

#### Example Scenario

**Week 1-2**: User does freeform bench press 3 times
- Session 1: 135x10, 135x10, 135x10 (range 8-12)
- Session 2: 135x12, 135x12, 135x11 (hit top!)
- Session 3: 135x12, 135x12, 135x12 (hit top again!)

**Week 3**: User creates "Push Day" plan from Session 3
- Plan includes bench press at 135 lbs, 8-12 reps

**Week 3 (first workout with new plan)**: 
- User does bench with plan: 135x12, 135x12
- System fetches bench press history: finds 3 previous sessions
- Rule triggers: "Hit top of range 2 of last 3 sessions"
- **Suggestion generated**: Increase to 140 lbs, reset to 8 reps

**Result**: User gets useful suggestion on FIRST workout with new plan because system uses all bench press history, not just plan-specific history.

#### Edge Case: Exercise Variations

If your catalog has variations (e.g., "bench_press_barbell" vs "bench_press_dumbbell"):
- They're tracked separately (different catalogID)
- This is correct - they're different movements with different strength curves
- No cross-pollution between variations

#### Implementation Check

```swift
// In SuggestionGenerator
private static func fetchHistory(
    catalogID: String,
    context: ModelContext
) -> [ExercisePerformance] {
    // This descriptor already filters by catalogID AND completed sessions
    let descriptor = ExercisePerformance.matching(catalogID: catalogID)
    guard let performances = try? context.fetch(descriptor) else { return [] }
    
    // Return last 3-5 sessions (regardless of which plan they came from)
    return Array(performances.prefix(3))
    
    // ✅ This naturally handles:
    // - New plans with existing exercise history
    // - Multiple plans using same exercise
    // - Freeform → Plan transitions
}
```

**Conclusion**: Your existing `catalogID`-based approach already supports new plans created from sessions perfectly. No changes needed - just verify that `ExercisePerformance.matching(catalogID:)` fetches across all plans/sessions.

### Complete Rule Summary

All rules organized by priority and implementation phase:

**Priority 1 - Safety (Ship First):**
- Rule 1.1: Below Range → Reduce Weight (applies to regular sets only)
- Rule 7.2: Volume Spike + Drop → Reduce Volume

**Priority 2 - Progressive Overload (Ship First):**
- Rule 2.1: Double Progression (Range Mode) → Add Weight & Reset Reps (regular sets only)
- Rule 2.2: Double Progression (Target Mode) → Add Weight
- Rule 2.3: Large Overshoot → Bigger Weight Jump

**Priority 3 - Prescription Cleanup (Ship First):**
- Rule 3.1: User Uses Different Weight → Match Behavior
- Rule 3.2: Set Type Mismatch → Update Prescription
- Rule 6.1: Warmup Acting Like Working Set → Convert or Reduce
- Rule 6.2: Drop Set Without Base → Add Structure
- Rule 6.5: Too Many Failure Sets → Convert to Regular
- Rule 7.1: Stagnation → Volume or Rest Increase

**Priority 4 - Volume Management (Phase 3):**
- Rule 4.1: Add Set (very conservative, requires 3+ sessions)

**Priority 5 - Rest Time (Phase 2):**
- Rule 5.1: Consistently Rest Longer → Update (only if effectiveRest > 0)
- Rule 5.2: Short Rest + Declining Performance → Increase
- Rule 6.3: Super Sets → Individual Rest Mode
- Rule 6.4: Super Set Followed by Regular → Increase Rest on Regular

**Priority 6 - Policy Adjustments (Phase 3):**
- Rule 6.6: Narrow Rep Range for Consistency

---

### Suggested Implementation Order

**Minimal Viable Rule Set (Ship First):**
1. Set Type Eligibility System - Foundation for all rules
2. Rule 2.1: Double Progression (Range Mode) - Core feature
3. Rule 1.1: Below Range → Reduce Weight - Safety
4. Rule 3.1: Match User's Actual Weight - Cleanup friction
5. Rule 3.2: Match Set Type - Cleanup friction
6. Cooldown & Deduplication System - Prevent spam

**Phase 2 Expansion:**
7. Rule 2.2: Double Progression (Target Mode)
8. Rule 2.3: Large Overshoot → Bigger Jump
9. Rule 5.1: Consistently Rest Longer (with effectiveRest check)
10. Rule 6.1: Warmup Cleanup
11. Rule 6.3: Super Set Rest Mode

**Phase 3 Advanced:**
12. Rule 7.1: Stagnation Detector
13. Rule 7.2: Volume Spike + Drop
14. Rule 4.1: Add Set (with strong evidence)
15. Rule 6.2, 6.4, 6.5: Drop/Super/Failure set refinements
16. Rule 5.2: Short Rest + Declining Performance

---

### Implementation Architecture

**File Structure:**
```
VillainArc/Data/Classes/Suggestions/
├── SuggestionGenerator.swift         // Main coordinator
├── RuleEngine.swift                  // Rule evaluation logic
├── MetricsCalculator.swift           // Compute SetMetrics, ExerciseMetrics
├── SuggestionDeduplicator.swift      // Cooldown & conflict resolution
└── Rules/
    ├── ProgressiveOverloadRules.swift
    ├── SafetyRules.swift
    ├── CleanupRules.swift
    ├── VolumeRules.swift
    ├── RestTimeRules.swift
    └── PolicyRules.swift
```

**Entry Point (Complete Pipeline):**
```swift
@MainActor
class SuggestionGenerator {
    static func generateSuggestions(
        for session: WorkoutSession,
        context: ModelContext
    ) {
        guard let plan = session.workoutPlan else { 
            print("No plan associated - skipping suggestion generation")
            return 
        }
        
        for exercisePerf in session.sortedExercises {
            guard let prescription = exercisePerf.prescription else { 
                print("No prescription for \(exercisePerf.name) - skipping")
                continue 
            }
            
            // 1. Fetch history (2-3 prior sessions for this exercise)
            let history = fetchHistory(catalogID: exercisePerf.catalogID, context: context)
            guard history.count >= 2 else { 
                print("Insufficient history for \(exercisePerf.name) (need 2+, have \(history.count))")
                continue 
            }
            
            // 2. Select eligible sets (progression sets = first 1-2 regular)
            let progressionSets = selectProgressionSets(from: exercisePerf)
            guard !progressionSets.isEmpty else {
                print("No eligible progression sets for \(exercisePerf.name)")
                continue
            }
            
            // 3. Calculate metrics across sessions
            let metrics = MetricsCalculator.calculate(
                current: exercisePerf,
                history: history,
                prescription: prescription
            )
            
            // 4. Run rules in priority order
            var candidateSuggestions: [PrescriptionChange] = []
            
            // Priority 1: Safety
            candidateSuggestions.append(contentsOf: SafetyRules.evaluate(
                metrics: metrics,
                prescription: prescription,
                session: session,
                context: context
            ))
            
            // Priority 2: Progressive Overload
            candidateSuggestions.append(contentsOf: ProgressiveOverloadRules.evaluate(
                metrics: metrics,
                prescription: prescription,
                session: session,
                context: context
            ))
            
            // Priority 3: Cleanup
            candidateSuggestions.append(contentsOf: CleanupRules.evaluate(
                metrics: metrics,
                prescription: prescription,
                session: session,
                context: context
            ))
            
            // Priority 5: Rest Time (only if effectiveRest > 0)
            candidateSuggestions.append(contentsOf: RestTimeRules.evaluate(
                metrics: metrics,
                prescription: prescription,
                session: session,
                context: context
            ))
            
            // 5. Deduplicate and resolve conflicts
            let finalSuggestions = SuggestionDeduplicator.process(
                suggestions: candidateSuggestions,
                prescription: prescription,
                context: context
            )
            
            // 6. Insert into context
            for suggestion in finalSuggestions {
                context.insert(suggestion)
                print("Created suggestion: \(suggestion.changeType) for \(exercisePerf.name)")
            }
        }
    }
    
    private static func fetchHistory(
        catalogID: String,
        context: ModelContext
    ) -> [ExercisePerformance] {
        let descriptor = ExercisePerformance.matching(catalogID: catalogID)
        guard let performances = try? context.fetch(descriptor) else { return [] }
        
        // Return last 3 completed sessions
        return Array(performances.prefix(3))
    }
    
    private static func selectProgressionSets(
        from performance: ExercisePerformance
    ) -> [SetPerformance] {
        let regularSets = performance.sortedSets.filter { 
            $0.type == .regular && $0.complete 
        }
        
        // Take first 1-2 regular sets (freshest, highest quality)
        return Array(regularSets.prefix(2))
    }
}
```

**Deduplicator Implementation:**
```swift
@MainActor
class SuggestionDeduplicator {
    static func process(
        suggestions: [PrescriptionChange],
        prescription: ExercisePrescription,
        context: ModelContext
    ) -> [PrescriptionChange] {
        var filtered: [PrescriptionChange] = []
        
        for suggestion in suggestions {
            // Check cooldown (recent similar suggestions)
            if hasSimilarRecentSuggestion(
                changeType: suggestion.changeType,
                targetSet: suggestion.targetSetPrescription,
                targetExercise: suggestion.targetExercisePrescription,
                context: context
            ) {
                print("Skipping due to cooldown: \(suggestion.changeType)")
                continue
            }
            
            // Check if recently rejected
            if wasRecentlyRejected(
                changeType: suggestion.changeType,
                targetSet: suggestion.targetSetPrescription,
                context: context
            ) {
                print("Skipping due to recent rejection: \(suggestion.changeType)")
                continue
            }
            
            filtered.append(suggestion)
        }
        
        // Resolve conflicts (same target, different changes)
        return resolveConflicts(filtered)
    }
    
    private static func hasSimilarRecentSuggestion(
        changeType: ChangeType,
        targetSet: SetPrescription?,
        targetExercise: ExercisePrescription?,
        context: ModelContext
    ) -> Bool {
        let twoWeeksAgo = Date().addingTimeInterval(-14 * 24 * 60 * 60)
        
        let descriptor = FetchDescriptor<PrescriptionChange>(
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        
        guard let allChanges = try? context.fetch(descriptor) else { return false }
        
        return allChanges.contains { change in
            change.createdAt > twoWeeksAgo &&
            change.changeType == changeType &&
            change.targetSetPrescription?.id == targetSet?.id &&
            change.targetExercisePrescription?.id == targetExercise?.id &&
            (change.decision == .pending || 
             change.decision == .deferred || 
             change.decision == .accepted)
        }
    }
    
    private static func wasRecentlyRejected(
        changeType: ChangeType,
        targetSet: SetPrescription?,
        context: ModelContext
    ) -> Bool {
        let oneMonthAgo = Date().addingTimeInterval(-30 * 24 * 60 * 60)
        
        let descriptor = FetchDescriptor<PrescriptionChange>(
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        
        guard let allChanges = try? context.fetch(descriptor) else { return false }
        
        return allChanges.contains { change in
            change.createdAt > oneMonthAgo &&
            change.changeType == changeType &&
            change.targetSetPrescription?.id == targetSet?.id &&
            change.decision == .rejected
        }
    }
    
    private static func resolveConflicts(
        _ suggestions: [PrescriptionChange]
    ) -> [PrescriptionChange] {
        // Group by target (set or exercise ID)
        var byTarget: [UUID: [PrescriptionChange]] = [:]
        
        for suggestion in suggestions {
            let targetID = suggestion.targetSetPrescription?.id ?? 
                           suggestion.targetExercisePrescription?.id ?? 
                           UUID()
            
            if byTarget[targetID] == nil {
                byTarget[targetID] = []
            }
            byTarget[targetID]?.append(suggestion)
        }
        
        var resolved: [PrescriptionChange] = []
        
        for (_, group) in byTarget {
            if group.count == 1 {
                resolved.append(contentsOf: group)
                continue
            }
            
            // Multiple suggestions for same target - pick highest priority
            // Priority order: Safety > Overload > Cleanup > Volume > Rest > Policy
            let priorityOrder: [ChangeType: Int] = [
                .decreaseWeight: 1,      // Safety
                .increaseWeight: 2,      // Overload
                .decreaseReps: 2,        // Overload
                .increaseReps: 3,        // Cleanup
                .changeSetType: 3,       // Cleanup
                .increaseRest: 5,        // Rest
                .decreaseRest: 5,        // Rest
                .addSet: 4,              // Volume
                .removeSet: 4,           // Volume
            ]
            
            let sorted = group.sorted { a, b in
                let aPriority = priorityOrder[a.changeType] ?? 10
                let bPriority = priorityOrder[b.changeType] ?? 10
                return aPriority < bPriority
            }
            
            // Keep highest priority
            if let best = sorted.first {
                resolved.append(best)
            }
        }
        
        return resolved
    }
}
```
```

---

### Helper Extensions

**Array Safe Subscript:**
```swift
extension Array {
    subscript(safe index: Int) -> Element? {
        return indices.contains(index) ? self[index] : nil
    }
}
```

**Muscle Classification:**
```swift
extension Muscle {
    var isLowerBody: Bool {
        switch self {
        // Major lower body
        case .quads, .hamstrings, .glutes, .calves:
            return true
        // Minor lower body
        case .adductors, .abductors:
            return true
        default:
            return false
        }
    }
    
    var isUpperBody: Bool {
        switch self {
        // Major upper body
        case .chest, .back, .shoulders, .biceps, .triceps:
            return true
        // Minor upper body
        case .upperChest, .lowerChest, .midChest, .lats, .lowerBack,
             .upperTraps, .lowerTraps, .midTraps, .rhomboids,
             .frontDelt, .sideDelt, .rearDelt, .rotatorCuff,
             .longHeadBiceps, .shortHeadBiceps, .brachialis,
             .longHeadTriceps, .lateralHeadTriceps, .medialHeadTriceps,
             .forearms, .wrists:
            return true
        default:
            return false
        }
    }
    
    var isCore: Bool {
        switch self {
        case .abs, .obliques, .upperAbs, .lowerAbs:
            return true
        default:
            return false
        }
    }
}
```

---

### Fatigue Detection (Future Enhancement)

While not generating suggestions yet, track these signals:

**Intra-Session Fatigue:**
```swift
struct FatigueSignals {
    let repDropoffPercent: Double  // First set reps vs last set reps
    let averageRepsVsTarget: Double
    let restTimeIncrease: Double  // Early sets vs late sets
}

func detectFatigue(exercisePerf: ExercisePerformance) -> FatigueSignals {
    let sets = exercisePerf.sortedSets.filter { $0.type == .regular }
    guard sets.count >= 2 else { return FatigueSignals(repDropoffPercent: 0, averageRepsVsTarget: 0, restTimeIncrease: 0) }
    
    let firstSetReps = Double(sets.first?.reps ?? 0)
    let lastSetReps = Double(sets.last?.reps ?? 0)
    let dropoff = firstSetReps > 0 ? (firstSetReps - lastSetReps) / firstSetReps : 0
    
    return FatigueSignals(
        repDropoffPercent: dropoff,
        averageRepsVsTarget: 0,  // Calculate later
        restTimeIncrease: 0      // Calculate later
    )
}
```

**Future Action**: If `repDropoffPercent > 0.4` (40% drop), flag in reasoning but don't auto-suggest volume reduction yet. Let user decide.

---

## Outcome Evaluation System

### When to Evaluate

**Trigger**: After completing a workout session with the plan

**Process**:
```swift
@MainActor
class OutcomeEvaluator {
    static func evaluateOutcomes(
        for session: WorkoutSession,
        context: ModelContext
    ) {
        guard let plan = session.workoutPlan else { return }
        
        // Fetch all pending outcome changes for this plan
        let pendingChanges = fetchPendingOutcomeChanges(for: plan, context: context)
        
        for change in pendingChanges {
            evaluateChange(change, basedOn: session, context: context)
        }
    }
    
    private static func evaluateChange(
        _ change: PrescriptionChange,
        basedOn session: WorkoutSession,
        context: ModelContext
    ) {
        // Match performance to prescription
        guard let performance = findMatchingPerformance(for: change, in: session) else {
            // Can't evaluate (exercise not performed)
            change.outcome = .ignored
            change.evaluatedInSession = session
            change.evaluatedAt = Date()
            return
        }
        
        // Apply evaluation rules
        let outcome = determineOutcome(change: change, performance: performance)
        change.outcome = outcome
        change.evaluatedInSession = session
        change.evaluatedAt = Date()
    }
}
```

### Evaluation Rules

#### Outcome: `.good`

**Criteria**:
- Weight increase: User completed all reps at new weight
- Rep increase: User completed new rep target consistently
- Rest decrease: User maintained performance with less rest
- Rep range change: User stays within new range

**Example**:
```swift
if change.changeType == .increaseWeight {
    let newWeight = change.newValue ?? 0
    let targetReps = setPrescription.targetReps
    
    // Check if user hit target reps at new weight
    if setPerformance.weight >= newWeight && setPerformance.reps >= targetReps {
        return .good
    }
}
```

#### Outcome: `.tooAggressive`

**Criteria**:
- Weight increase: User failed to hit target reps (fell short by 2+ reps)
- Volume increase: User didn't complete sets
- Intensity indicators: marked as failure set, or excessive rest needed

**Example**:
```swift
if change.changeType == .increaseWeight {
    let newWeight = change.newValue ?? 0
    let targetReps = setPrescription.targetReps
    
    if setPerformance.weight >= newWeight && setPerformance.reps < targetReps - 1 {
        return .tooAggressive
    }
}
```

#### Outcome: `.tooEasy`

**Criteria**:
- User exceeded new targets significantly
- Completed reps well beyond prescribed (e.g., prescribed 8, did 12+)
- Suggests the change wasn't aggressive enough

**Example**:
```swift
if change.changeType == .increaseWeight {
    let newWeight = change.newValue ?? 0
    let targetReps = setPrescription.targetReps
    
    if setPerformance.weight >= newWeight && setPerformance.reps > targetReps + 3 {
        return .tooEasy
    }
}
```

#### Outcome: `.ignored`

**Criteria**:
- User accepted the suggestion but didn't follow it during workout
- Used different weight/reps than prescribed
- Exercise not performed in session

**Example**:
```swift
if change.decision == .accepted {
    let newWeight = change.newValue ?? 0
    
    // Check if user actually used the new weight
    if abs(setPerformance.weight - newWeight) > 2.5 {
        return .ignored
    }
}
```

#### Outcome: `.userModified`

**Criteria**:
- User manually edited the prescription before outcome could be evaluated
- Already set during editing (via `markChangeAsUserOverride()`)

**Note**: This is set during editing, not during evaluation.

### Outcome Confidence Scoring (Future Enhancement)

Track confidence in outcome evaluation:
```swift
struct OutcomeEvaluation {
    let outcome: Outcome
    let confidence: Double  // 0.0 to 1.0
    let reason: String
}

// Example:
// - Only 1 set performed with new weight → confidence: 0.6
// - 3+ sets completed successfully → confidence: 0.95
```

---

## Context Gathering Tools

### Purpose

V1 uses a **minimal context footprint**:
1. **Exercise History** (cached) for trend awareness
2. **Prescription + Performance snapshots** passed directly per exercise

Change history and user readiness remain valuable but are **post-V1** (after outcomes are recorded).

### Tool Functions

#### 1. Exercise History (Cached)

```swift
struct ExerciseHistoryContext {
    let catalogID: String
    let totalSessions: Int
    let last30DaySessions: Int
    let progressionTrend: ProgressionTrend
    let lastWorkoutDate: Date?

    // PRs + recent averages (summary only)
    let bestEstimated1RM: Double
    let bestWeight: Double
    let bestVolume: Double
    let last3AvgWeight: Double
    let last3AvgVolume: Double
    let typicalSetCount: Int
}

enum ProgressionTrend {
    case improving      // Weight/volume increasing over time
    case plateau        // Stagnant for 3+ sessions
    case regressing     // Decreasing performance
}

@MainActor
class ExerciseHistoryProvider {
    static func fetchContext(
        catalogID: String,
        context: ModelContext
    ) -> ExerciseHistoryContext? {
        let descriptor = ExerciseHistory.forCatalogID(catalogID)
        guard let history = try? context.fetch(descriptor).first else {
            return nil
        }

        return ExerciseHistoryContext(
            catalogID: history.catalogID,
            totalSessions: history.totalSessions,
            last30DaySessions: history.last30DaySessions,
            progressionTrend: history.progressionTrend,
            lastWorkoutDate: history.lastWorkoutDate,
            bestEstimated1RM: history.bestEstimated1RM,
            bestWeight: history.bestWeight,
            bestVolume: history.bestVolume,
            last3AvgWeight: history.last3AvgWeight,
            last3AvgVolume: history.last3AvgVolume,
            typicalSetCount: history.typicalSetCount
        )
    }
}
```

#### 2. Suggestion History (Post-V1)

```swift
struct SuggestionHistoryContext {
    let catalogID: String
    let recentChanges: [PrescriptionChange]  // Last 5-10 suggestions for this exercise
    let acceptanceRate: Double               // % of suggestions accepted
    let successRate: Double                  // % of accepted with .good outcome
}

@MainActor
class SuggestionHistoryProvider {
    static func fetchHistory(
        catalogID: String,
        limit: Int = 10,
        context: ModelContext
    ) -> SuggestionHistoryContext {
        let descriptor = FetchDescriptor<PrescriptionChange>(
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        
        guard let allChanges = try? context.fetch(descriptor) else {
            return SuggestionHistoryContext(
                catalogID: catalogID,
                recentChanges: [],
                acceptanceRate: 0,
                successRate: 0
            )
        }
        
        let exerciseChanges = allChanges.filter { $0.catalogID == catalogID }
        let recent = Array(exerciseChanges.prefix(limit))
        
        let accepted = recent.filter { $0.decision == .accepted }
        let successful = accepted.filter { $0.outcome == .good }
        
        return SuggestionHistoryContext(
            catalogID: catalogID,
            recentChanges: recent,
            acceptanceRate: recent.isEmpty ? 0 : Double(accepted.count) / Double(recent.count),
            successRate: accepted.isEmpty ? 0 : Double(successful.count) / Double(accepted.count)
        )
    }
}
```

#### 3. User Readiness Context (Post-V1)

```swift
struct UserReadinessContext {
    let sleepQuality: Double?        // 0-1 from Apple Health
    let restingHeartRate: Int?       // from Apple Health
    let heartRateVariability: Double? // from Apple Health
    let preMoodLevel: MoodLevel      // from PreWorkoutMood
    let daysSinceLastWorkout: Int
    let readinessScore: Double       // Computed 0-1
}

@MainActor
class UserReadinessProvider {
    static func fetchReadiness(
        for session: WorkoutSession,
        context: ModelContext
    ) -> UserReadinessContext {
        // Fetch from Apple Health (future integration)
        // For now, use pre-workout mood + days since last workout
        
        let lastSession = try? context.fetch(WorkoutSession.completedSessions(limit: 2))
        let daysSince = lastSession?.dropFirst().first?.startedAt.timeIntervalSince(session.startedAt) ?? 0
        let daysSinceCount = Int(abs(daysSince) / 86400)
        
        return UserReadinessContext(
            sleepQuality: nil,
            restingHeartRate: nil,
            heartRateVariability: nil,
            preMoodLevel: session.preMood.mood,
            daysSinceLastWorkout: daysSinceCount,
            readinessScore: calculateReadiness(mood: session.preMood.mood, daysSince: daysSinceCount)
        )
    }
    
    private static func calculateReadiness(mood: MoodLevel, daysSince: Int) -> Double {
        var score = 0.5  // Base neutral
        
        // Mood contribution (0-0.3)
        switch mood {
        case .great: score += 0.3
        case .good: score += 0.15
        case .neutral: score += 0.0
        case .low: score -= 0.15
        case .veryLow: score -= 0.3
        case .notSet: score += 0.0
        }
        
        // Recovery contribution (0-0.2)
        if daysSince == 1 { score += 0.1 }
        else if daysSince >= 2 { score += 0.2 }
        else if daysSince == 0 { score -= 0.1 }  // Same day (maybe second workout)
        
        return max(0.0, min(1.0, score))
    }
}
```

### Integration into Rules

**Example: Adjust Weight Increment Based on Context**

```swift
func determineWeightIncrement(
    muscle: Muscle,
    exerciseHistory: ExerciseHistoryContext,
    userReadiness: UserReadinessContext
) -> Double {
    // Base increment
    var increment = muscle.isLowerBody ? 10.0 : 5.0
    
    // Reduce if plateau or regressing
    if exerciseHistory.progressionTrend == .plateau {
        increment *= 0.5  // Smaller jump
    } else if exerciseHistory.progressionTrend == .regressing {
        return -increment  // Suggest weight decrease
    }
    
    // Reduce if low readiness
    if userReadiness.readinessScore < 0.4 {
        increment *= 0.5  // Conservative progression
    }
    
    // Increase if consistently improving
    if exerciseHistory.progressionTrend == .improving && userReadiness.readinessScore > 0.7 {
        increment *= 1.5  // More aggressive
    }
    
    return increment
}
```

---

## AI Integration (V1)

### Apple FoundationModels Framework

**Purpose**: Generate V1 AI suggestions per exercise (weight/reps + rep-range only).

**V1 Approach**:
- One AI call per exercise after workout completion
- Pass prescription + performance snapshots for that exercise plus exercise history summary
- Clear model context between exercises (no cross-exercise memory)
- Output can include multiple suggestions per exercise (set-level + rep-range)

### Guided Generation Approach

**Input Structure** (passed to Foundation Model):
```swift
struct ExerciseSuggestionInput: Codable {
    let catalogID: String
    let exerciseName: String
    let trainingStyle: String
    let prescription: PrescriptionSnapshot
    let performance: PerformanceSnapshot
    let exerciseHistory: ExerciseHistoryContext?
}

struct PrescriptionSnapshot: Codable {
    let repRangeMode: String
    let repRangeLower: Int?
    let repRangeUpper: Int?
    let repRangeTarget: Int?
    let sets: [SetPrescriptionSnapshot]
}

struct SetPrescriptionSnapshot: Codable {
    let index: Int
    let type: String
    let targetWeight: Double
    let targetReps: Int
}

struct PerformanceSnapshot: Codable {
    let sessionDate: Date
    let sets: [SetPerformanceSnapshot]
}

struct SetPerformanceSnapshot: Codable {
    let index: Int
    let type: String
    let weight: Double
    let reps: Int
    let restSeconds: Int
    let complete: Bool
}
```

**Output Structure** (from Foundation Model):
```swift
struct ExerciseSuggestionOutput: Codable {
    let suggestions: [AISuggestion]
}

struct AISuggestion: Codable {
    let changeType: String  // Weight/reps + rep-range only for V1
    let targetSetIndex: Int?
    let previousValue: Double?
    let newValue: Double
    let reasoning: String
}
```

### Foundation Model Integration

```swift
import FoundationModels

@MainActor
class AISuggestionGenerator {
    static func generateSuggestions(
        input: ExerciseSuggestionInput,
        context: ModelContext
    ) async throws -> [PrescriptionChange] {
        let session = LanguageModelSession(instructions: "You are a strength coach...")

        let response = try await session.respond(
            to: "Analyze this exercise and suggest changes.",
            generating: ExerciseSuggestionOutput.self
        )

        let output = response.value
        
        // Convert AI suggestions to PrescriptionChange records
        return output.suggestions.compactMap { aiSuggestion in
            createChangeFromAI(
                suggestion: aiSuggestion,
                prescription: input.prescription,
                context: context
            )
        }
    }
    
    private static func createChangeFromAI(
        suggestion: AISuggestion,
        prescription: PrescriptionSnapshot,
        context: ModelContext
    ) -> PrescriptionChange? {
        guard let changeType = ChangeType(rawValue: suggestion.changeType) else {
            return nil
        }
        
        let change = PrescriptionChange()
        change.source = .ai
        change.decision = .pending
        change.outcome = .pending
        change.changeType = changeType
        change.previousValue = suggestion.previousValue
        change.newValue = suggestion.newValue
        change.changeReasoning = suggestion.reasoning
        change.createdAt = Date()
        // ... set targets, etc.
        
        context.insert(change)
        return change
    }
}
```

### Hybrid Workflow

```swift
@MainActor
func generateAllSuggestions(
    for session: WorkoutSession,
    useAI: Bool = false,
    context: ModelContext
) async {
    // Step 1: Generate rule-based suggestions
    SuggestionGenerator.generateSuggestions(for: session, context: context)
    
    // Step 2: Optionally refine with AI
    if useAI {
        for exercisePerf in session.sortedExercises {
            guard let prescription = exercisePerf.prescription else { continue }
            
            // Gather context
            let exerciseHistory = ExerciseHistoryProvider.fetchHistory(
                catalogID: exercisePerf.catalogID,
                context: context
            )
            let suggestionHistory = SuggestionHistoryProvider.fetchHistory(
                catalogID: exercisePerf.catalogID,
                context: context
            )
            let userReadiness = UserReadinessProvider.fetchReadiness(
                for: session,
                context: context
            )
            
            // Fetch rule-based suggestions for this exercise
            let ruleChanges = prescription.changes.filter { $0.source == .rules && $0.decision == .pending }
            
            // Build input
            let input = SuggestionGenerationInput(
                prescription: PrescriptionSnapshot(from: prescription),
                performance: PerformanceSnapshot(from: exercisePerf),
                exerciseHistory: exerciseHistory,
                suggestionHistory: suggestionHistory,
                userReadiness: userReadiness,
                ruleBasedSuggestions: ruleChanges.map { PrescriptionChangeSnapshot(from: $0) }
            )
            
            // Generate AI suggestions
            let aiSuggestions = try? await AISuggestionGenerator.refineSuggestions(
                input: input,
                context: context
            )
            
            // AI suggestions are added alongside rule-based ones
            // User sees both sources in UI (can be grouped or separate)
        }
    }
}
```

---

## Key Design Decisions Summary

### 1. Session History Requirement: **3 Sessions (Recommended)**

**Decision:** Start with 3-session minimum for stability.

**Reasoning:**
- 3 sessions = 2 comparison points (reduces false positives)
- ~1-2 weeks wait (reasonable for evidence)
- Users trust suggestions that feel "earned"
- Can lower to 2 sessions later based on acceptance rates

**Application:**
- Progressive overload: 2 of last 3 sessions show pattern
- Safety rules: 2 of last 3 sessions show problem
- Cleanup/Volume/Policy: All 3 sessions show need

---

### 2. History Lookup: **Exercise-Based (catalogID), Not Plan-Based**

**Decision:** Use `catalogID` to fetch all exercise history across all plans/sessions.

**Benefits:**
- ✅ New plans immediately leverage existing exercise history
- ✅ Freeform → Plan transition is seamless
- ✅ Multiple plans using same exercise share learning
- ✅ No wasted data (every workout counts)

**Example:**
```
Week 1-2: User benches 3x in freeform sessions
Week 3: User creates plan including bench press
Week 3 first workout: System has 3 sessions of history → can generate suggestions
```

**Implementation:** Already handled by `ExercisePerformance.matching(catalogID:)` 

---

### 3. Progression Set Selection: **Adaptive to Training Style**

**Decision:** Intelligently select "top sets" based on weight pattern AND set type labels.

**Strategy:**
1. **If user marks set types properly**: Trust their labels, take top 2 regular sets by weight
2. **If user doesn't mark types**: Infer from weight pattern
   - Heaviest first → take first 2 sets
   - Pyramid up → take peak weight set(s)
   - Straight sets → take first 2 sets
3. **Mixed approach**: Combine regular sets + heaviest non-warmup

**Why:** Different training styles (5x5 heavy-first vs warmup-pyramid) require different selection logic. System adapts automatically.

---

### 4. Set Type Suggestions: **Helpful, Not Nagging**

**Decision:** Suggest set type changes based on weight patterns, but only if user shows consistent pattern for 2+ sessions.

**Rules:**
- Warmup with heavy weight → suggest convert to regular
- Regular set with light weight (< 70% max) early in sequence → suggest warmup
- Clear pattern across all sets → batch suggest structure (warmup/regular/backoff)

**Important:** Don't spam users who intentionally keep all sets as `.regular`. Only suggest if pattern is clear AND consistent.

---

### 5. Rest Time Rules: **Only When Intentional**

**Decision:** Never suggest rest changes for drop/super set chains (effectiveRest = 0).

**Logic:**
```swift
let effectiveRest = exercise.effectiveRestSeconds(after: previousSet)
if effectiveRest > 0 {
    // OK to suggest rest time changes
} else {
    // This is a drop/super set chain - skip rest suggestions
}
```

**Why:** Drop/super sets are intentionally zero-rest. Suggesting rest here would break the training style.

---

### 6. Cooldown System: **Prevent Suggestion Spam**

**Decision:** 
- 14-day cooldown for similar suggestions (same changeType + target)
- 30-day cooldown for rejected suggestions
- Conflict resolution (same target, multiple changes → pick highest priority)

**Why:** Users will ignore the entire system if spammed with redundant suggestions.

---

### 7. Priority System: **Safety First, Then Adaptation**

**Decision:** When multiple rules apply, use priority:
1. Safety (below range, volume spike)
2. Progressive overload (hit top, increase weight)
3. Cleanup (match behavior, fix set types)
4. Volume (add/remove sets)
5. Rest time (optimize recovery)
6. Policy (rep range adjustments)

**Why:** If user needs to reduce weight (safety) and also hit top of range (overload), safety wins.

---

## Model Verification Summary

All references in this specification have been verified against actual project models:

### ✅ Enums Verified
- **ExerciseSetType**: `.warmup`, `.regular`, `.superSet`, `.dropSet`, `.failure` - All correct
- **RepRangeMode**: `.notSet`, `.target`, `.range`, `.untilFailure` - All correct
- **RestTimeMode**: `.allSame`, `.individual` - All correct
- **Muscle**: All 43 muscle cases verified and properly categorized in weight increment logic
- **Decision**: `.pending`, `.accepted`, `.rejected`, `.deferred`, `.userOverride` - All correct
- **Outcome**: `.pending`, `.good`, `.tooAggressive`, `.tooEasy`, `.ignored`, `.userModified` - All correct
- **SuggestionSource**: `.rules`, `.ai`, `.user` - All correct

### ✅ Models Verified
- **RepRangePolicy**: `activeMode`, `lowerRange`, `upperRange`, `targetReps` - All correct
- **RestTimePolicy**: `activeMode`, `allSameSeconds`, `seconds(for:)`, `defaultRegularSeconds()` - All correct
- **ExercisePerformance**: 
  - `effectiveRestSeconds(after:)` ✅ Exists (VillainArc/Data/Models/Sessions/ExercisePerformance.swift:55)
  - `bestEstimated1RM`, `bestWeight`, `totalVolume` ✅ Exist
  - `historicalBestEstimated1RM(in:)`, `historicalBestWeight(in:)`, `historicalBestVolume(in:)` ✅ Exist
  - `matching(catalogID:)` ✅ Exists (line 140)
- **SetPerformance**: `type`, `weight`, `reps`, `restSeconds`, `complete`, `completedAt`, `estimated1RM`, `volume` - All correct
- **PrescriptionChange**: All relationships and properties verified
- **WorkoutPlan+Editing**: `saveContext(context:)` ✅ Exists in DataManager.swift

### ✅ ChangeType Cases Verified
All change types referenced in rules exist:
- Set-level: `increaseWeight`, `decreaseWeight`, `increaseReps`, `decreaseReps`, `increaseRest`, `decreaseRest`, `changeSetType`, `addSet`, `removeSet`
- Exercise-level: `increaseRepRangeLower/Upper/Target`, `decreaseRepRangeLower/Upper/Target`, `changeRepRangeMode`, `changeRestTimeMode`, `increaseRestTimeSeconds`, `decreaseRestTimeSeconds`
- Exercise structure: `reorderExercise`, `removeExercise`, `addExercise`

### ✅ Helper Methods Required (To Be Implemented)
These are new helpers needed for the suggestion system (not in current codebase):
- `selectProgressionSets(from:)` - NEW: Adaptive set selection based on training style
- `detectTrainingStyle(_:)` - NEW: Infer pattern from weight progression
- `shouldReduceWeight(metrics:history:prescription:)` - NEW: Rule evaluation
- `shouldProgressWeight(metrics:history:prescription:)` - NEW: Rule evaluation
- `determineWeightIncrement(currentWeight:primaryMuscle:)` - NEW: Smart weight increments
- All rule evaluation functions - NEW

### ✅ Array Safe Subscript Extension
```swift
extension Array {
    subscript(safe index: Int) -> Element? {
        return indices.contains(index) ? self[index] : nil
    }
}
```
**Status**: Not found in codebase - ADD THIS to a Helpers file or Extensions.swift

---

## Implementation Roadmap

### V1 Scope (First Ship)

- Minimum OS: iOS 26+ (FoundationModels available)
- Change types: weight + reps, plus rep-range suggestions when missing
- Training style + rep range aware
- One AI call per exercise (context cleared each call)
- Inputs: prescription + performance snapshots + exercise history summary
- Outputs: one or more suggestions per exercise
- Outcomes/evaluation deferred

### Phase 1: Core Infrastructure (Current State ✅)

- [x] `PrescriptionChange` model with all relationships
- [x] `Decision` and `Outcome` enums
- [x] `WorkoutPlan+Editing` with change tracking and user override logic
- [x] `SuggestionGrouping` for UI display
- [x] `ExercisePerformance` / `SetPerformance` with PR calculations

### Phase 2: V1 Suggestion Generation (Rules + AI)

**Goal**: Generate weight/rep suggestions after workouts (per exercise)

**Tasks**:
1. Create `SuggestionGenerator.swift` in `VillainArc/Data/Classes/`
   - Rules for weight/reps only
   - Rep-range suggestions when missing or inconsistent
   - Training style-aware set selection
2. Create `AISuggestionGenerator.swift` in `VillainArc/Data/Classes/`
   - One AI call per exercise
   - Input: prescription + performance snapshots + exercise history summary
   - Output: multiple suggestions allowed (weight/reps + rep-range)
3. Hook into workout completion flow:
   - In `WorkoutSession` finalization, call generators and save `PrescriptionChange`
4. Ensure suggestions appear in `DeferredSuggestionsView`
5. Test with sample data

**Files to Create**:
- `VillainArc/Data/Classes/SuggestionGenerator.swift`
- `VillainArc/Data/Classes/AISuggestionGenerator.swift`

### Phase 3: Outcome Evaluation (Post-V1)

**Goal**: Evaluate suggestion outcomes after subsequent workouts

**Tasks**:
1. Create `OutcomeEvaluator.swift` in `VillainArc/Data/Classes/`
2. Hook into workout completion flow to update outcomes
3. Add outcome display in suggestion review UI

**Files to Create**:
- `VillainArc/Data/Classes/OutcomeEvaluator.swift`

### Phase 4: User Readiness Context (Post-V1)

**Goal**: Incorporate health data and readiness signals

**Tasks**:
1. Create `UserReadinessProvider.swift`
2. Adjust suggestion generation based on readiness score
3. Add UI indicators for readiness (optional)

**Files to Create**:
- `VillainArc/Data/Classes/UserReadinessProvider.swift`

### Phase 5: Advanced Rules (Post-V1)

**Goal**: Expand rule set with more sophisticated logic

**Tasks**:
1. Plateau detection and deload suggestions
2. Fatigue-based volume adjustments
3. Exercise substitution suggestions (when performance drops)
4. Progressive overload pacing (based on training age)

### Phase 6: AI Expansion (Post-V1)

**Goal**: Add richer context + tool calling and AI arbitration

**Tasks**:
1. Add tool calling (history, readiness, suggestion history)
2. Use suggestion history + outcomes to bias AI decisions
3. Optional UI toggle for AI enhancements
4. A/B test rule-based vs AI-refined suggestions

---

## Specification Complete - Verification Checklist

### ✅ Model Alignment Verified
- [x] All enum values match actual project enums
- [x] All model properties reference correct field names
- [x] All helper methods verified to exist or marked as NEW
- [x] `ExerciseSetType` raw values are `Int` (not String) - Verified
- [x] `effectiveRestSeconds(after:)` exists and works correctly
- [x] `ExercisePerformance.matching(catalogID:)` returns correct descriptor
- [x] `saveContext(context:)` exists in DataManager.swift
- [x] All 43 `Muscle` cases properly handled in weight increment logic

### ✅ Design Decisions Finalized
- [x] **3-session minimum** for stability (can adjust based on data)
- [x] **Exercise-based history** (catalogID) not plan-based
- [x] **Adaptive progression set selection** based on training style
- [x] **Set type suggestions** based on weight patterns
- [x] **effectiveRest check** for all rest time rules
- [x] **Priority system** for conflict resolution
- [x] **Cooldown system** (14 days similar, 30 days rejected)

### ✅ Complete Rule Set Documented
- [x] Priority 1: Safety Rules (2 rules)
- [x] Priority 2: Progressive Overload (3 rules)
- [x] Priority 3: Cleanup (6 rules)
- [x] Priority 4: Volume Management (1 rule - very conservative)
- [x] Priority 5: Rest Time (4 rules)
- [x] Priority 6: Policy Adjustments (1 rule)
- [x] **Total**: 17 rules with stability checks and evidence requirements

### ✅ Implementation Architecture Ready
- [x] File structure defined
- [x] Entry point with complete pipeline
- [x] Deduplicator with cooldown logic
- [x] Conflict resolution by priority
- [x] Metrics calculation framework
- [x] Rule evaluation structure
- [x] Phase-by-phase roadmap

### 📋 Required New Code (V1)
1. **Array safe subscript** extension (add to Helpers)
2. **ExerciseSetType + Muscle helpers** (eligibility + increment sizing)
3. **Training style detection helpers**
4. **MetricsCalculator.swift** for weight/rep-focused metrics
5. **SuggestionGenerator.swift** (rules: weight/reps + rep-range inference)
6. **AISuggestionGenerator.swift** (one call per exercise; map to `PrescriptionChange`)
7. **Minimal dedup/cooldown** (optional for V1, can be post-V1)

---

## Summary

This specification provides:
- ✅ **Complete data model** (already implemented & verified)
- ✅ **User editing reconciliation** (already implemented & verified)
- ✅ **Suggestion grouping UI** (already implemented)
- ✅ **Model alignment** (all references verified against actual code)
- 🔲 **V1 suggestion generation (rules + AI)** (weight/reps + rep-range)
- 🔲 **Outcome evaluation system** (post-V1)
- 🔲 **Tool calling + richer context** (post-V1)
- 🔲 **AI expansion roadmap** (post-V1)

### What Makes This Specification Production-Ready
1. **Every model reference verified** against actual Swift code
2. **All enum cases confirmed** to exist with correct types
3. **Training style adaptability** handles multiple user approaches
4. **3-session minimum** provides stability without excessive wait
5. **Exercise-based history** works perfectly for new plans from sessions
6. **Set type intelligence** helps users who don't manually categorize
7. **effectiveRest checking** prevents inappropriate rest suggestions
8. **Comprehensive rule set** covers progression, safety, cleanup, and optimization
9. **Anti-spam system** with cooldowns and deduplication
10. **Clear implementation phases** with V1 → post-V1 outcomes → tool calling

### Ready to Ship

**V1 Implementation** can begin immediately with:
1. Add Array safe subscript extension
2. Add ExerciseSetType + Muscle + training style helpers
3. Implement MetricsCalculator (weight/reps)
4. Implement V1 rules (progressive overload + rep-range inference)
5. Implement `AISuggestionGenerator` (per-exercise call)
6. Wire up generators to workout completion
7. Test with sample data

**Next Steps**: Begin V1 implementation!
